# 要件定義書: CodeContext (Draft 1/3) [確定版]

## 1. プロジェクト概要

### 1.1. プロジェクト名

**CodeContext**

### 1.2. 目的

本プロジェクトは、ソースコードの構造と文脈を「人間」と「AI (LLM)」の両方が効率的に理解できる形にするための VS Code 拡張機能を開発することを目的とする。

* **対 人間:** 複雑なコードの依存関係（ファイル、クラス、関数）をグラフとして可視化し、デバッグやコードリーディング時の認知負荷を下げる。
* **対 LLM (将来構想):** RAG (Retrieval-Augmented Generation) の精度向上のため、コードの「意味（要約）」と「構造（グラフ）」をセットにしたコンテキストを提供する基盤を作る。

### 1.3. フェーズ定義

本要件定義書では、**Phase 1: MVP (Minimum Viable Product)** の仕様を定義する。

* **Phase 1 (今回):** Pythonコードの静的解析（TS実装）、グラフデータベース(CozoDB)への格納、Cytoscape.jsによる可視化。**LLM連携（要約・ベクトル化）は実装しない。**
* **Phase 2 (将来):** LLMによる要約生成、ベクトル検索、GraphRAG実装。
* **Phase 3 (将来):** 他言語対応、マルチモーダル対応。

## 2. システムアーキテクチャ

本拡張機能は、VS Code の拡張機能アーキテクチャに基づき、以下の2つのプロセスで構成される。

### 2.1. Extension Host (バックエンド / TypeScript)

Node.js 環境で動作するメインプロセス。

* **責務:** 拡張機能のライフサイクル管理、ファイルシステム操作、解析ロジック実行、データベース操作。
* **構成技術:**
* Runtime: Node.js (VS Code内蔵)
* Language: TypeScript
* Parser: `web-tree-sitter` (Wasm版) + `tree-sitter-python` (.wasmファイル)
* Database: `cozo-lib-wasm` (インメモリ動作 + ファイルバックアップ)



### 2.2. Webview (フロントエンド / UI)

VS Code 内の独立したブラウザ環境で動作するUIプロセス。

* **責務:** グラフの描画、ユーザーインタラクションの受け付け、検索UIの提供。
* **構成技術:**
* Framework: React
* Visualization: `Cytoscape.js`
* Bundler: Webpack or Vite



### 2.3. データ永続化

* 解析データは実行中はメモリ上（CozoDB In-Memory）に保持し、高速なクエリ応答を実現する。
* 永続化のため、プロジェクトルート直下の `.code-context/` ディレクトリにDBのダンプファイル（`db_dump.cozo`）を保存・読み込みを行う。

## 3. 機能要件 (バックエンド / ロジック)

### 3.1. アクティベーションと初期化

* **REQ-B-01 (オンデマンド起動):**
* 拡張機能は VS Code 起動時には重い処理（スキャン等）を行わない。
* ユーザーがコマンド `CodeContext: Open Graph` を実行した時点でアクティベーション（起動）する。


* **REQ-B-02 (データロード & Sync):**
* 起動時、`.code-context/db_dump.cozo` が存在すれば CozoDB にインポートする。
* インポート後、**即座にファイルシステムの更新日時をチェックし、差分があるファイルのみ再解析を行う（Incremental Sync）。**
* ダンプファイルが存在しない場合は、新規に全スキャンを行う。



### 3.2. ソースコード解析 (Parser)

* **REQ-B-03 (対象言語):**
* MVPでは `.py` ファイルのみを解析対象とする。


* **REQ-B-04 (除外設定):**
* `.gitignore` ファイルをパースし、除外されているファイル・ディレクトリはスキャン対象から外す。
* 将来的に `.llmignore` をサポート可能な設計とする。


* **REQ-B-05 (解析粒度・シンボル抽出):**
* `web-tree-sitter` を使用し、以下のシンボルを抽出する。
1. **File:** ファイルパス、最終更新日時
2. **Class:** クラス定義（名前、開始行、終了行）
3. **Function/Method:** 関数定義（名前、開始行、終了行）、所属クラス


* 以下の関係性（エッジ）を抽出する。
1. **Import:** `import A`, `from A import B` の依存関係（ファイル間のリンク）
2. **Contains:** ファイル→クラス→メソッド の包含関係（親子関係）
3. **Call (Best Effort):** 関数内での呼び出し。**MVPでは「関数名の一致」による推定レベルとする。**（厳密な型解決は行わないため、同名の別メソッドへのリンクが発生しうるが許容する）





### 3.3. データベース操作 (CozoDB)

* **REQ-B-06 (データ更新と削除):**
* 解析結果を Datalog 形式のデータ（Facts）に変換し、CozoDB に `put` (Upsert) する。
* **削除検知:** スキャン時にファイルシステム上に存在しなくなったファイルに対応するノードおよびエッジを、DBから削除する。


* **REQ-B-07 (データ保存):**
* 以下のタイミングでメモリ上のDBを `.code-context/db_dump.cozo` に書き出す。
1. Webview上の「保存」ボタン押下時。
2. (オプション) 拡張機能の非アクティブ化（Deactivate）時。




* **REQ-B-08 (クエリインターフェース):**
* フロントエンドからの要求に応じ、以下の Datalog クエリを実行し JSON で返す。
1. `getNetwork`: 全ノード・エッジの取得（初期表示用。ノード数が多い場合は制限付き）
2. `getNeighbors(nodeId)`: 特定ノードに隣接するノードの取得（ドリルダウン用）
3. `searchNodes(keyword)`: ファイルパスや関数名による検索




## 4. データモデル設計 (CozoDB Schema)

CozoDB（Datalog）に格納するデータのスキーマ定義。
MVPでは、複雑さを避けるため**3つのリレーション（テーブル）**で構成する。

### 4.1. ファイル情報 (files)

プロジェクト内のファイルを管理するノード。

* **Relation Name:** `files`
* **Columns:**
* `path` (String, Key): プロジェクトルートからの相対パス（例: `src/main.py`）。一意なIDとして使用。
* `last_modified` (Float): 最終更新タイムスタンプ。増分スキャンの判定に使用。
* `language` (String): 言語識別子（例: `python`）。
* `=>` (Payload Divider)
* `summary` (String, Nullable): **(Phase 2)** LLM生成要約。
* `vector` (List<Float>, Nullable): **(Phase 2)** Embeddingベクトル。



### 4.2. シンボル情報 (symbols)

ファイル内のクラスや関数を管理するノード。

* **Relation Name:** `symbols`
* **Columns:**
* `id` (String, Key): 一意な識別子。形式は `{file_path}:{name}` または `{file_path}:{class}.{method}` とする。
* `=>`
* `file_path` (String): 所属ファイルのパス（`files` への外部キー的役割）。
* `name` (String): シンボル名（例: `my_function`）。
* `kind` (String): シンボルの種類（`class`, `function`, `method`）。
* `start_line` (Int): 定義開始行（0-indexed）。
* `end_line` (Int): 定義終了行。
* `summary` (String, Nullable): **(Phase 2)** LLM生成要約。
* `vector` (List<Float>, Nullable): **(Phase 2)** Embeddingベクトル。



### 4.3. 依存関係 (relations)

ノード間のエッジ（つながり）を管理する。

* **Relation Name:** `relations`
* **Columns:**
* `from_id` (String, Key): 呼び出し元のID（file path または symbol id）。
* `to_id` (String, Key): 呼び出し先のID。
* `type` (String, Key): 関係の種類。
* `import`: ファイル間の依存。
* `contains`: ファイルがクラスを含む、クラスがメソッドを含む。
* `call`: 関数が別の関数を呼ぶ。


* `=>`
* `count` (Int): 呼び出し回数（オプション、重み付け用）。



---

## 5. フロントエンド機能要件 (UI/UX)

Webview（React + Cytoscape.js）上で提供する機能と画面レイアウト。

### 5.1. 画面レイアウト

VS Codeのエディタ領域全体（または分割ペイン）を使用する。

* **Main Canvas:** 画面全体の90%を占めるグラフ描画エリア。
* **Control Bar:** 画面上部または下部に配置するフローティングツールバー。
* `[検索ボックス]`: ノード検索用。
* `[保存]ボタン`: DBダンプの書き出しを実行。
* `[再スキャン]ボタン`: 強制的に全ファイルをリスキャン。
* `[レイアウト初期化]ボタン`: ノード配置をリセット。



### 5.2. グラフ可視化 (Visualization)

* **REQ-F-01 (レイアウトアルゴリズム):**
* `cose-bilkent` または `fcose` (Fast Compound Spring Embedder) を採用。
* クラスやファイルによる「グループ化（Compound Nodes）」を視覚的に表現し、スパゲッティ化を防ぐ。


* **REQ-F-02 (ノードスタイル):**
* **File:** 四角形 □。色はグレー/青系。
* **Function/Method:** 円形 ○。色は緑/オレンジ系。
* **Edge:** 矢印付き線。`type` によって線種（実線/点線）や色を変える。


* **REQ-F-03 (パフォーマンス):**
* ノード数が500を超える場合、初期表示では「FileノードとImport関係」のみを表示し、詳細はズームまたはクリックでロードする「Level of Detail (LOD)」制御を検討する。



### 5.3. インタラクション (Interaction)

* **REQ-F-04 (クリック動作 - 詳細表示):**
* ノードを左クリック (Click) すると、そのノードに直接つながっている隣接ノード（Call先、Call元）のみをハイライトし、他を半透明にする。
* ノードを選択状態にし、詳細情報（名前、パス、(Phase 2: 要約)）をサイドパネルまたはツールチップに表示する。


* **REQ-F-05 (右クリック動作 - コードジャンプ):**
* ノードを右クリック (Context Menu) し、「**Go to Code**」を選択すると、VS Codeのエディタ側で該当ファイルの該当行を開く。
* ジャンプ時、Webview（グラフ）は閉じずにアクティブなまま維持する。


* **REQ-F-06 (検索機能):**
* 検索ボックスに入力すると、部分一致するノードをキャンバス上でフォーカス（Zoom & Center）し、赤枠などで強調表示する。



---

## 6. インターフェース仕様 (Backend <-> Frontend)

Extension Host と Webview 間で交わされるメッセージプロトコル（JSON形式）。

### 6.1. From Extension To Webview (To UI)

* `UPDATE_GRAPH`: DBから取得した最新のノード・エッジデータを送信。
```json
{ "command": "UPDATE_GRAPH", "data": { "nodes": [...], "edges": [...] } }

```


* `STATUS_MESSAGE`: スキャン中の進捗やエラーメッセージを表示。
```json
{ "command": "STATUS_MESSAGE", "text": "Scanning... (5/10 files)", "level": "info" }

```



### 6.2. From Webview To Extension (To Backend)

* `REQUEST_INIT`: 起動時、初期データを要求する。
* `EXECUTE_SAVE`: DBのダンプ保存を要求する。
* `EXECUTE_RESCAN`: ファイルの再スキャンを要求する。
* `JUMP_TO_CODE`: 指定されたファイルの行へジャンプを要求する。
```json
{ "command": "JUMP_TO_CODE", "path": "src/main.py", "line": 15 }

```






## 7. 実装・開発構成

### 7.1. ディレクトリ構成案

VS Code拡張機能の標準的な構成に、Webview（React）とWasmリソースを統合した構成とする。

```text
code-context/
├── .vscode/               # デバッグ設定など
├── resources/             # アイコン画像など
├── src/                   # Extension Host (Backend) ソースコード
│   ├── extension.ts       # エントリーポイント (Activate/Deactivate)
│   ├── panels/            # Webviewパネル管理クラス
│   │   └── GraphPanel.ts
│   ├── core/              # コアロジック
│   │   ├── db.ts          # CozoDB操作ラッパー
│   │   ├── parser.ts      # Tree-sitter解析ロジック
│   │   └── scanner.ts     # ファイル走査・更新検知
│   └── types.ts           # 共通型定義
├── webview-ui/            # Webview (Frontend) ソースコード
│   ├── index.html         # Reactのエントリーポイント
│   ├── src/
│   │   ├── App.tsx        # メインコンポーネント
│   │   ├── components/    # 検索バーなどのパーツ
│   │   ├── graph/         # Cytoscape設定・スタイル定義
│   │   └── types.ts       # Frontend用型定義
│   └── vite.config.ts     # Frontendビルド設定
├── wasm/                  # Wasmバイナリ置き場 (ビルド時にdistへコピー)
│   ├── tree-sitter.wasm
│   ├── tree-sitter-python.wasm
│   └── cozo_lib_wasm_bg.wasm
├── package.json           # 依存関係定義
└── tsconfig.json

```

### 7.2. 技術スタック & 依存ライブラリ (Phase 1)

**Backend (Extension Host):**

* `vscode`: VS Code API
* `web-tree-sitter`: Wasm版 Tree-sitter パーサー
* `cozo-lib-wasm`: CozoDB Wasm版
* `glob`: ファイル検索用 (高速化のため `fast-glob` 推奨)

**Frontend (Webview):**

* `react`, `react-dom`: UIフレームワーク
* `cytoscape`: グラフ可視化エンジン
* `cytoscape-fcose`: レイアウト拡張 (FCose layout)
* `@vscode/webview-ui-toolkit`: VS CodeネイティブなUI部品 (ボタン、入力欄など)
* `vite`: ビルドツール (高速なHMRのため)

### 7.3. ビルドプロセス

VS Code拡張機能は `webpack` または `esbuild` でバンドルされるのが一般的だが、今回は Webview (React) 側を `Vite` でビルドし、その出力 (`dist/assets/*`) を拡張機能が読み込む形をとる。

1. **Frontend Build:** `webview-ui/` 内で Vite ビルド → JS/CSS を生成。
2. **Resource Copy:** `.wasm` ファイル群を拡張機能の出力ディレクトリ (`dist/`) にコピー。
3. **Backend Build:** `src/` をコンパイル。

## 8. 実装ロードマップ (Phase 1)

以下の4ステップでMVPを完成させる。

### Step 1: プロジェクト基盤の構築

* `yo code` でプロジェクト作成。
* React (Vite) 環境の統合。
* Wasmファイル (`tree-sitter`, `cozo`) のロードテスト。
* **ゴール:** コマンドを実行すると、空のReact画面が表示され、コンソールに "DB Loaded" と表示される。

### Step 2: 解析エンジンの実装 (Core Logic)

* `parser.ts`: Pythonコード文字列を渡し、Class/Function/Import を抽出できるか確認。
* `db.ts`: CozoDBスキーマの定義と、データ投入(`put`)、クエリ(`run`)の実装。
* **ゴール:** 指定したPythonファイルを解析し、その結果がCozoDBに格納されていることをログで確認する。

### Step 3: API連携と可視化 (Visualization)

* Extension -> Webview へグラフデータ（JSON）を送信する処理の実装。
* Cytoscape.js のセットアップとノードスタイリング。
* `fcose` レイアウトの適用。
* **ゴール:** 解析結果がグラフとして画面に描画される。

### Step 4: インタラクションの実装 (Interaction)

* ノードクリック時のハイライト処理。
* 右クリック「Go to Code」の実装（WebviewからExtensionへメッセージ送信 → エディタを開く）。
* DBダンプの保存・読み込み処理。
* **ゴール:** 実用的なデバッグツールとして動作するMVP完成。



### MVP 2: "Intelligence"（AI実装フェーズ）

**目的:** 「ただの地図」から「意味を理解する地図」への進化。

1. **自動要約エージェント:**
* ファイル保存時に、差分があった関数のコードをLLM（Gemini/Ollama）に投げ、1〜2行の要約を生成して `summary` カラムに保存する。


2. **ローカル埋め込み (Embeddings):**
* `Transformers.js` を導入し、要約テキストをブラウザ(Webview)内でベクトル化して `vector` カラムに保存。


3. **スマート・コンテキスト出力:**
* グラフ上でノードを選択し「クリップボードにコピー」を押すと、単なるコードではなく**「依存関係図 ＋ 要約 ＋ コードスケルトン」**という、LLMが最も理解しやすい形式でテキスト化する機能。



### MVP 3: "Expansion"（多言語・対話フェーズ）

**目的:** ツールとしての汎用性とインターフェースの深化。

1. **マルチランゲージ対応:**
* `tree-sitter-typescript`, `tree-sitter-java`, `tree-sitter-html` のWasmを追加。
* 言語間の依存（例: PythonのFlaskから呼ばれるHTMLテンプレート）を解析ロジックに追加。


2. **Chat with Graph (GraphRAG):**
* 検索バーをチャット形式に進化させる。
* 「ユーザー認証周りのロジックはどうなってる？」と聞くと、グラフDBを検索し、関連ノードをハイライトしながら回答する機能。


3. **チーム共有 (Git Sync):**
* `.code-context/` 内のデータをGitで共有した際、コンフリクトしないようなマージロジックの実装（またはJSON形式の最適化）。
